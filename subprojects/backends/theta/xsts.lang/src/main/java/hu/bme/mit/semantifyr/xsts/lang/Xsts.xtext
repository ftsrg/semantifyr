/*
 * SPDX-FileCopyrightText: 2023-2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

grammar hu.bme.mit.semantifyr.xsts.lang.Xsts with org.eclipse.xtext.common.Terminals

generate xsts "http://www.bme.hu/mit/2025/xsts"

import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

XstsModel:
    {XstsModel}
    enumDeclarations+=EnumDeclaration*
    variableDeclarations+=VariableDeclaration*
    tran=Transition?
    init=Init?
    env=Env?
    property=Property?
;

EnumDeclaration:
	'type' name=Identifier ':' '{'
		literals+=EnumLiteral (',' literals+=EnumLiteral)*
	'}'
;

EnumLiteral:
	name=Identifier
;

VariableDeclaration:
	control?='ctrl'? 'var' name=Identifier ':' type=Type ('=' expression=Expression)?
;

Transition:
	'trans' steps+=SequenceOperation
    (
        'or' steps+=SequenceOperation
    )*
;

Init returns Transition:
	'init' steps+=SequenceOperation
    (
        'or' steps+=SequenceOperation
    )*
;

Env returns Transition:
	'env' steps+=SequenceOperation
    (
        'or' steps+=SequenceOperation
    )*
;

Property:
	'prop' '{'
		invariant=Expression
	'}'
;

Type:
    BooleanType
    | IntegerType
    | ArrayType
    | EnumType
;

BooleanType:
    {BooleanType} 'boolean'
;

IntegerType:
    {IntegerType} 'integer'
;

ArrayType:
    '[' indexType=Type ']' '->' elementType=Type
;

EnumType:
    enumDeclaration=[EnumDeclaration|Identifier]
;

Operation:
	 HavocOperation
	 | AssumptionOperation
	 | AssignmentOperation
	 | LocalVarDeclOperation
	 | ChoiceOperation
	 | SequenceOperation
	 | IfOperation
	 | ForOperation
;

HavocOperation:
	'havoc' reference=ElementReferenceExpression ';'
;

AssumptionOperation:
	'assume' expression=Expression ';'
;

AssignmentOperation:
	reference=WriteReferenceExpression ':=' expression=Expression ';'
;

LocalVarDeclOperation returns VariableDeclaration:
	'local' 'var' name=Identifier ':' type=Type ('=' expression=Expression)? ';'
;

SequenceOperation:
    {SequenceOperation} '{'
		(operation+=Operation)*
	'}'
;

ChoiceOperation:
	'choice' operation+=Operation
	(
		'or' operation+=Operation
	)*
	(
		'else' else=Operation
	)?
;

IfOperation:
	'if' '(' guard=Expression ')'
	body=Operation
	('else' else=Operation)?
;

LoopVar returns VariableDeclaration:
   name=Identifier
;

ForOperation:
    'for' loopVar=LoopVar 'from' from=Expression 'to' to=Expression 'do' body=Operation
;

Expression:
	OperatorExpression
;

OperatorExpression returns Expression:
    BooleanOperator
;

IfThenElseExpression returns Expression:
    'if' guard=Expression 'then' then=Expression 'else' else=Expression
    | BooleanOperator
;

enum BooleanOp:
    AND='&&' | OR='||' | XOR='xor' | IFF='iff' | imply='=>'
;

BooleanOperator returns Expression:
    ComparisonOperator (
        {BooleanOperator.left=current} op=BooleanOp right=ComparisonOperator
    )*
;

enum ComparisonOp:
	LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | EQ="==" | NOT_EQ="!="
;

ComparisonOperator returns Expression:
    AdditiveOperator (
        {ComparisonOperator.left=current} op=ComparisonOp right=AdditiveOperator
    )*
;

enum AdditiveOp returns ArithmeticOp:
	ADD="+" | SUB="-"
;

AdditiveOperator returns Expression:
    MultiplicativeOperator (
        {ArithmeticBinaryOperator.left=current} op=AdditiveOp right=MultiplicativeOperator
    )*
;

enum MultiplicativeOp returns ArithmeticOp:
    MUL='*' | DIV='/' | MOD='%' | REM='rem'
;

MultiplicativeOperator returns Expression:
    UnaryOperator (
        {ArithmeticBinaryOperator.left=current} op=MultiplicativeOp right=UnaryOperator
    )*
;

UnaryOperator returns Expression:
	NegationOperator
	| ArithmeticUnaryOperator
	| PostfixUnaryExpression
;

NegationOperator:
	'!' body=UnaryOperator
;

enum UnaryOp:
	PLUS="+" | MINUS="-"
;

ArithmeticUnaryOperator:
    op=UnaryOp body=UnaryOperator
;

PostfixUnaryExpression returns Expression:
    PrimaryExpression -> (
        ({WriteIndexingSuffixExpression.primary=current} '[' index=Expression ('<-' expression=Expression)? ']')
    )*
;

PrimaryExpression returns Expression:
	  ElementReferenceExpression
	| LiteralExpression
	| '(' Expression ')'
;

// Literal expressions

LiteralExpression:
	 LiteralBoolean
	 | LiteralInteger
	 | LiteralArray
;

LiteralBoolean:
	value = BooleanValue
;

LiteralInteger:
	value = INT
;

LiteralArray:
    ConcreteLiteralArray
	| DefaultLiteralArray
;

ConcreteLiteralArray:
    '['
        (indexExpression+=Expression '<-' valueExpression+=Expression ',')+
        ('<' indexType=Type '>')?
        'default' '<-' elseExpression=Expression
    ']'
;

DefaultLiteralArray:
    '[' '<' indexType=Type '>' 'default' '<-' elseExpression=Expression ']'
;

BooleanValue returns Ecore::EBoolean:
	'true' | 'false'
;

WriteReferenceExpression returns Expression:
    ElementReferenceExpression
    | ArrayReferenceExpression
;

ArrayReferenceExpression returns ReadIndexingSuffixExpression:
    primary=ElementReferenceExpression '[' index=Expression ']'
;

ElementReferenceExpression:
	element=[Ecore::EObject|QualifiedIdentifier]
;

QualifiedIdentifier:
    Identifier ('.' Identifier)*
;

Identifier:
    ID
;

terminal ID: ('a'..'z'|'A'..'Z'|'_'|'$') ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'$')*;
