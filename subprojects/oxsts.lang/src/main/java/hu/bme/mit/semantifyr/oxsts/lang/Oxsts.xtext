/*
 * SPDX-FileCopyrightText: 2023-2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

grammar hu.bme.mit.semantifyr.oxsts.lang.Oxsts with org.eclipse.xtext.common.Terminals

import "http://www.bme.hu/mit/2023/oxsts"
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

Model returns Ecore::EObject:
    OxstsModelPackage
    | InlinedOxsts
;

InlinedOxsts:
    'inlined' 'oxsts' 'of' classDeclaration=[ClassDeclaration|QualifiedIdentifier]

    variables+=InlinedVariable*
    rootFeature=RootFeature?

    initTransition=InlinedInitTransition
    mainTransition=InlinedMainTransition
    property=InlinedProperty
;

RootFeature returns FeatureDeclaration:
    kind=FeatureKind name=Identifier ':' type=[TypeDeclaration|QualifiedIdentifier] multiplicity=Multiplicity?
;

InlinedVariable returns VariableDeclaration:
    annotation=AnnotationContainer
    'var' name=Identifier
    (':' type=[DomainDeclaration|QualifiedIdentifier])?
    multiplicity=Multiplicity?
    (':=' expression=Expression)?
    ';'?
;

InlinedInitTransition returns TransitionDeclaration:
    kind=TransitionKind
    branches += SequenceOperation
    ('or' branches += SequenceOperation)*
;

InlinedMainTransition returns TransitionDeclaration:
    kind=TransitionKind
    branches += SequenceOperation
    ('or' branches += SequenceOperation)*
;

InlinedProperty returns PropertyDeclaration:
    'prop' '{'
        expression=Expression
    '}'
;

OxstsModelPackage:
    'package' name=QualifiedIdentifier ';'?
    imports += ImportStatement*
    declarations += TopLevelDeclaration*
;

ImportStatement:
    'import' importedPackage=[OxstsModelPackage|QualifiedIdentifier] ';'?
;

Annotation:
    '@' declaration=[AnnotationDeclaration|QualifiedIdentifier]
    ('(' (arguments += Argument (',' arguments += Argument)* ','?)? ')')?
;

TopLevelDeclaration returns Declaration:
    {AnnotationContainer} annotations+=Annotation*

    -> (
        {DataTypeDeclaration.annotation=current}
        'extern' 'datatype' name=Identifier ';'?
    |
        {EnumDeclaration.annotation=current}
        'enum' name=Identifier (';'? | '{'
            literals+=EnumLiteral? (',' literals+=EnumLiteral)* ','?
        '}')
    |
        {RecordDeclaration.annotation=current}
        'record' name=Identifier (';'? | '{'
            members += RecordMember*
        '}')
    |
        {ClassDeclaration.annotation=current}
        abstract?='abstract'? 'class' name=Identifier
        (':' superTypes += [ClassDeclaration|QualifiedIdentifier] (',' superTypes += [ClassDeclaration|QualifiedIdentifier])* ','? )?
        (';'? | '{'
            members += ClassMember*
        '}')
    |
        {AnnotationDeclaration.annotation=current}
        'annotation' name=Identifier
        ('(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')')?
        ';'?
    // |
        // {FunctionDeclaration}
        // 'fun' name=Identifier
        // '(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')'
        // (':' returnType=[TypeDeclaration|QualifiedIdentifier])?
        // '{'
        //     expression=Expression
        // '}'
    // | PatternDeclaration
    )
;

EnumLiteral:
    name=Identifier
;

RecordMember returns Declaration:
    {AnnotationContainer} annotations+=Annotation*

    -> (
        {VariableDeclaration.annotation=current}
        'var' name=Identifier
        (':' type=[DomainDeclaration|QualifiedIdentifier])?
        multiplicity=Multiplicity?
        (':=' expression=Expression)?
        ';'?
    // |
        // {FunctionDeclaration}
        // redefine?='redefine'? 'fun' name=Identifier
        // '(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')'
        // (':' returnType=[TypeDeclaration|QualifiedIdentifier])?
        // '{'
        //     expression=Expression
        // '}'
    )
;

ClassMember returns Declaration:
    {AnnotationContainer} annotations+=Annotation*

    -> (
        {VariableDeclaration.annotation=current}
        'var' name=Identifier
        (':' type=[DomainDeclaration|QualifiedIdentifier])?
        multiplicity=Multiplicity?
        (':=' expression=Expression)?
        ';'?
    // |
        // {FunctionDeclaration}
        // -> redefine?='redefine'? 'fun' name=Identifier
        // '(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')'
        // (':' returnType=[TypeDeclaration|QualifiedIdentifier])?
        // '{'
        //     expression=Expression
        // '}'
    |
        {PropertyDeclaration.annotation=current}
        redefine?='redefine'? 'prop'
        (
            name=Identifier
            '(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')'
        )?
        (':' returnType=[TypeDeclaration|QualifiedIdentifier])?
        '{'
            'return' expression=Expression ';'?
        '}'
    |
        {TransitionDeclaration.annotation=current}
        redefine?='redefine'? kind=TransitionKind
        (
            name=Identifier
            '(' (parameters += ParameterDeclaration (',' parameters += ParameterDeclaration)* ','?)? ')'
        )?
        branches += SequenceOperation
        ('or' branches += SequenceOperation)*
    |
        {FeatureDeclaration.annotation=current}
        redefine?='redefine'? kind=FeatureKind name=Identifier ':' type=[TypeDeclaration|QualifiedIdentifier] multiplicity=Multiplicity?
        (
            ('subsets' superset=[FeatureDeclaration|Identifier])?
            & ('opposite' opposite=[FeatureDeclaration|Identifier])?
            & ('redefines' redefined=[FeatureDeclaration|Identifier])?
        )
        (
            ';'?
            | '=' expression=Expression ';'?
            | '{'
                innerFeatures += InnerFeature*
            '}'
        )
    )
;

AnnotationContainer:
    {AnnotationContainer} annotations+=Annotation*
;

InnerFeature returns FeatureDeclaration:
    annotation = AnnotationContainer
    redefine?='redefine'? kind=FeatureKind name=Identifier ':' type=[TypeDeclaration|QualifiedIdentifier] multiplicity=Multiplicity?
    (
        ('subsets' superset=[FeatureDeclaration|Identifier])?
        & ('opposite' opposite=[FeatureDeclaration|Identifier])?
        & ('redefines' redefined=[FeatureDeclaration|Identifier])?
    )
    (
        ';'?
        | '=' expression=Expression ';'?
        | '{'
            innerFeatures += InnerFeature*
        '}'
    )
;

enum TransitionKind:
    TRAN='tran'
    | ENV='env'
    | INIT='init'
    | HAVOC='havoc'
;

enum FeatureKind:
    REFERENCE='refers'
    | CONTAINMENT='contains'
    | CONTAINER='container'
    | DERIVED='derived refers'
    | FEATURE='features'
;

Operation:
	HavocOperation
	| ChoiceOperation
	| SequenceOperation
	| AssumptionOperation
	| InlineOperation
	| AssignmentOperation
	| IfOperation
	| ForOperation
	| LocalVarDeclarationOperation
;

SequenceOperation:
    {SequenceOperation}
    '{'
        (steps+=Operation)*
    '}'
;

HavocOperation:
    'havoc' '(' reference=Expression ')' ';'?
;

ChoiceOperation:
    'choice' branches+=SequenceOperation
    ('or' branches+=SequenceOperation)*
;

AssumptionOperation:
    'assume' '(' expression=Expression ')' ';'?
;

AssignmentOperation:
    reference=PostfixUnaryExpression ':=' expression=Expression ';'?
;

IfOperation:
    'if' '(' guard=Expression ')'
    body=SequenceOperation
    ('else' else=SequenceOperation)?
;

LoopVariable returns VariableDeclaration:
    name=Identifier
;

ForOperation:
    'for' '(' loopVariable=LoopVariable 'in' rangeExpression=Expression ')'
    body=SequenceOperation
;

LocalVarDeclarationOperation:
    'var' name=Identifier
    (':' type=[DomainDeclaration|QualifiedIdentifier])?
    (-> multiplicity=Multiplicity)?
    (':=' expression=Expression)?
    ';'?
;

InlineOperation:
    InlineCall
    | InlineForOperation
    | InlineIfOperation
;

InlineCall:
    'inline' callExpression=DefiniteCallExpression ';'?
;

InlineForOperation:
    InlineSeqFor
    | InlineChoiceFor
;

InlineSeqFor:
    'inline' 'for' 'seq'? '(' loopVariable=LoopVariable 'in' rangeExpression=Expression ')' body=SequenceOperation
    ('else' else=SequenceOperation)?
;

InlineChoiceFor:
    'inline' 'for' 'choice' '(' loopVariable=LoopVariable 'in' rangeExpression=Expression ')' body=SequenceOperation
    ('else' else=SequenceOperation)?
;

InlineIfOperation:
    'inline' 'if' '(' guard=Expression ')' 
    body=SequenceOperation
    ('else' else=SequenceOperation)?
;

Multiplicity:
    DefiniteMultiplicity
    | UnboundedMultiplicity
;

UnboundedMultiplicity:
    {UnboundedMultiplicity} '[' ']'
;

DefiniteMultiplicity:
    '[' expression=Expression ']'
;

ParameterDeclaration:
    name=Identifier ':' type=[TypeDeclaration|QualifiedIdentifier] (multiplicity=Multiplicity)?
;

Argument:
    (parameter=[ParameterDeclaration|Identifier] '=')? expression=Expression
;

// Expressions

Expression:
    OperatorExpression
;

// Operator expressions

OperatorExpression returns Expression:
    BooleanOperator
;

enum BooleanOp:
    AND='&&' | OR='||' | XOR='^^' // | IFF='<->' | imply='->'
;

BooleanOperator returns Expression:
    ComparisonOperator -> (
        {BooleanOperator.left=current} op=BooleanOp right=ComparisonOperator
    )*
;

enum ComparisonOp:
    LESS='<' | LESS_EQ='<=' | GREATER='>' | GREATER_EQ='>=' | EQ='==' | NOT_EQ='!='
;

ComparisonOperator returns Expression:
    RangeExpression -> (
        {ComparisonOperator.left=current} op=ComparisonOp right=RangeExpression
    )*
;

RangeExpression returns Expression:
    AdditiveOperator -> (
        {RangeExpression.left=current} ('..' | exclusive?='..<') right=AdditiveOperator
    )?
;

enum AdditiveOp returns ArithmeticOp:
    ADD='+' | SUB='-'
;

AdditiveOperator returns Expression:
    MultiplicativeOperator -> (
        {ArithmeticBinaryOperator.left=current} op=AdditiveOp right=MultiplicativeOperator
    )*
;

enum MultiplicativeOp returns ArithmeticOp:
    MUL='*' | DIV='/' // | MOD='%' | REM='rem'
;

MultiplicativeOperator returns Expression:
    UnaryOperator -> (
        {ArithmeticBinaryOperator.left=current} op=MultiplicativeOp right=UnaryOperator
    )*
;

UnaryOperator returns Expression:
	NegationOperator
	| ArithmeticUnaryOperator
	| CallExpression
;

NegationOperator:
	'!' body=UnaryOperator
;

enum UnaryOp:
	PLUS='+' | MINUS='-'
;

ArithmeticUnaryOperator:
    op=UnaryOp body=UnaryOperator
;

CallExpression returns Expression:
     PostfixUnaryExpression -> (
        {CallSuffixExpression.primary=current} '(' (arguments += Argument (',' arguments += Argument)* ','? )? ')'
     )?
;

DefiniteCallExpression returns CallSuffixExpression:
    primary=PostfixUnaryExpression '(' (arguments += Argument (',' arguments += Argument)* ','?)? ')'
;

PostfixUnaryExpression returns Expression:
    PrimaryExpression -> (
        ({NavigationSuffixExpression.primary=current} optional?='?'? '.' member=[NamedElement|Identifier])
        | ({IndexingSuffixExpression.primary=current} '[' index=Expression ']')
    )*
;

PrimaryExpression returns Expression:
    DirectReferenceExpression
    | LiteralExpression
    | -> '(' Expression ')'
;

// Literal expressions

LiteralExpression:
    LiteralBoolean
    | LiteralInteger
    | LiteralInfinity
    | LiteralNothing
    | LiteralReal
    | LiteralString
    | ArrayLiteral
;

LiteralBoolean:
    value=BooleanValue
;

LiteralInteger:
    value=INT
;

LiteralInfinity:
    {LiteralInfinity} '*'
;

BooleanValue returns Ecore::EBoolean:
    'true' | 'false'
;

LiteralNothing:
    {LiteralNothing} 'nothing'
;

LiteralReal:
    value = Real
;

Real returns Ecore::EDouble:
	EXPONENTIAL | INT '.' (INT | EXPONENTIAL)
;

LiteralString:
    value=STRING
;

ArrayLiteral:
    {ArrayLiteral} '[' (values+=Expression (',' values+=Expression)* ','?)? ']'
;

// Reference expressions

DirectReferenceExpression:
    SelfReference
    | ElementReference
;

ElementReference:
    element=[NamedElement|QualifiedIdentifier]
;

SelfReference:
    {SelfReference} 'self'
;

QualifiedIdentifier:
    Identifier ('::' Identifier)*
;

Identifier:
    ID | QUOTED_ID | KEYWORD
;

KEYWORD:
    'init'
    | 'havoc'
    | 'prop'
;

@Override
terminal ID:
	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*
;

terminal EXPONENTIAL:
	INT ('e' | 'E') ('+' | '-')? INT
;

@Override
terminal STRING:
	'"' ( !('"' | '\r' | '\n') )* '"'
;

terminal QUOTED_ID:
	"'" ( !("'" | "\r" | "\n") )* "'"
;
