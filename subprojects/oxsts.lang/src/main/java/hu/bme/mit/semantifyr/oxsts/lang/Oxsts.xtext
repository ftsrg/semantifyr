/*
 * SPDX-FileCopyrightText: 2023-2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

grammar hu.bme.mit.semantifyr.oxsts.lang.Oxsts with org.eclipse.xtext.common.Terminals

import "http://www.bme.hu/mit/2023/oxsts" 
import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

Package:
    'package' name=ID
    imports += Import*
    (
        types += TypeLike
        | enums += Enum
        | patterns += Pattern
        | constraints += SemanticConstraint
    )*
;

Import:
    'import' package=[Package|FQN]
;

Property:
    'prop' name=ID? '{'
        invariant=Expression
    '}'
;

Enum:
    'enum' name=ID '{'
        literals+=EnumLiteral (',' literals+=EnumLiteral)* (',')?
    '}'
;

EnumLiteral:
    name=ID
;

TypeLike returns Type:
    Type
    | Target
;

Type:
    (abstract?='abstract')? 'type' name=ID (':' supertype=[Type|FQN])? ('{'
        (
            variables+=Variable
            | features+=Feature
            | initTransition+=InitTransition
            | transitions+=NamedTransition
            | mainTransition+=MainTransition
            | havocTransition+=HavocTransition
            | properties+=Property
        )*
    '}')?
;

Target:
    (abstract?='abstract')? 'target' name=ID (':' supertype=[Type|FQN])? ('{'
        (
            variables+=Variable
            | features+=Feature
            | initTransition+=InitTransition
            | transitions+=NamedTransition
            | mainTransition+=MainTransition
            | havocTransition+=HavocTransition
            | properties+=Property
        )*
    '}')?
;

NamedTransition returns Transition:
    TransitionModifier 'tran' name=ID TransitionBody
;

HavocTransition returns Transition:
    TransitionModifier 'havoc' TransitionBody
;

MainTransition returns Transition:
    TransitionModifier 'tran' TransitionBody
;

InitTransition returns Transition:
    TransitionModifier 'init' TransitionBody
;

fragment TransitionModifier returns Transition:
    (virtual?='virtual' | override?='override')?
;

fragment TransitionBody returns Transition:
    ('('(
        arguments+=Argument
        (',' arguments+=Argument)*
        (',')?
    )?')')?
    operation+=SequenceOperation ('or' operation+=SequenceOperation)*
;

Argument:
    name=ID ':' typing=Typing
;


Operation:
	   HavocOperation
	 | ChoiceOperation
	 | SequenceOperation
	 | AssumptionOperation
	 | InlineOperation
	 | AssignmentOperation
	 | IfOperation
;

SequenceOperation:
    {SequenceOperation}
    '{'
        (operation+=Operation)*
    '}'
;

HavocOperation:
    'havoc' '(' reference=ChainingExpression ')'
;

ChoiceOperation:
    'choice' operation+=SequenceOperation
    (
        'or' operation+=SequenceOperation
    )*
    (
        'else' else=SequenceOperation
    )?
;

AssumptionOperation:
    'assume' '(' expression=Expression ')'
;

AssignmentOperation:
    reference=ChainingExpression ':=' expression=Expression
;

IfOperation:
    'if' '(' guard=Expression ')'
    body = SequenceOperation
    (
        'else' else=SequenceOperation
    )?
;

InlineOperation:
    InlineCall
    | InlineChoice
    | InlineSeq
    | InlineIfOperation
;

InlineChoice:
    'inline' 'choice' reference=ChainingExpression '->' transition=[Transition|KeywordID]
    (
        'else' else=SequenceOperation
    )?
;

InlineSeq:
    'inline' 'seq' reference=ChainingExpression '->' transition=[Transition|KeywordID]
;

InlineCall:
    (static ?= 'static')? 'inline' ((reference=ChainingExpression '.' transition=[Transition|KeywordID]) | transition=[Transition|FQN]) '('(
        argumentBindings+=ArgumentBinding
        (',' argumentBindings+=ArgumentBinding)* (',')?
    )?')'
;

ArgumentBinding:
    expression=Expression
;


InlineIfOperation:
    'inline' 'if' '(' guard=Expression ')'
    body = SequenceOperation
    (
        'else' else=SequenceOperation
    )?
;

Variable:
    (control ?= 'ctrl')? 'var' name=ID
    ':' typing=Typing
    multiplicity=Multiplicity?
    ('=' expression=Expression)?
;

Feature returns Feature:
    ActualFeature
    | Containment
    | Reference
    | Derived
;

fragment FeatureDeclaration returns Feature:
    (name=ID | ((name=ID)? '::>' redefines=[Feature|FQN]))
    (':>' subsets+=[Feature|FQN])?
    ':' typing=Typing
    multiplicity=Multiplicity?
;

ActualFeature returns Feature:
	'feature' FeatureDeclaration
;

Containment:
    'containment' FeatureDeclaration
    ('{'
        features+=Feature*
    '}')?
;

Reference:
    'reference' FeatureDeclaration ('=' expression=Expression)?
;

Derived:
    'derived' 'reference' FeatureDeclaration 'as' 'pattern' pattern=[Pattern|FQN]
;

Multiplicity:
    DefiniteMultiplicity
    | UnboundedMultiplicity
;

UnboundedMultiplicity:
    {UnboundedMultiplicity} '[' ']'
;

DefiniteMultiplicity:
    RangeMultiplicity
    | ExactMultiplicity
;

RangeMultiplicity:
    '[' lowerBound=INT '..' upperBound=UpperBound ']'
;

ExactMultiplicity:
    '[' value=INT ']'
;

UpperBound returns Ecore::EInt:
    INT | "*"
;

Typing:
    DataType
    | ReferenceTyping
;

DataType:
    IntegerType
    | BooleanType
;

IntegerType:
    {IntegerType} 'Integer'
;

BooleanType:
    {BooleanType} 'Boolean'
;

ReferenceTyping:
    reference=ChainingExpression
;

// Instance

Instance:
    'instance' ':' containment=[Containment]
    (
        '{'
            (
                children+=Instance
                | associations+=Association
            )*
        '}'
    )?
;

Association:
    'association' feature=[Feature] '->' '(' instances+=[Instance] (',' instances+=[Instance])* ','? ')'
;

// Patterns

Pattern:
    'pattern' name=ID '('
        parameters+=Parameter
        (',' parameters+=Parameter)*
        (',')?
    ')'
    patternBodies += PatternBody
    ('or' patternBodies += PatternBody)*
;

Parameter:
    name=ID ':' type=[Type|FQN]
;

PatternBody:
    '{'
        (constraints += Constraint)*
    '}'
;

Constraint:
    TypeConstraint
    | FeatureConstraint
    | PatternConstraint
    | ExpressionConstraint
;

PatternVariable:
    name=ID
;

TypeConstraint:
    (negated?='neg')? type=[Type|FQN] '(' variables+=PatternVariable ')'
;

FeatureConstraint:
    (negated?='neg')? type=[Type|FQN] '.' feature=[Feature|KeywordID] '(' variables+=PatternVariable ',' variables+=PatternVariable ')'
;

PatternConstraint:
    (negated?='neg')? 'find' pattern=[Pattern|FQN] (transitiveClosure = TransitiveClosureKind)? '('
        variables+=PatternVariable
        (',' variables+=PatternVariable)*
        (',')?
    ')'
;

ExpressionConstraint:
    EqualityConstraint
    | InequalityConstraint
;

EqualityConstraint:
    variables+=PatternVariable '==' variables+=PatternVariable
;

InequalityConstraint:
    variables+=PatternVariable '!=' variables+=PatternVariable
;

SemanticConstraint:
    'neg' 'constraint' name=ID '('
       parameters+=Parameter
       (',' parameters+=Parameter)*
       (',')?
   ')'
   patternBodies += PatternBody
   ('or' patternBodies += PatternBody)*
;

enum TransitiveClosureKind:
    WithoutSelf = '+' | IncludeSelf = '*'
;

// Expressions

Expression:
    OperatorExpression
;

// Operator expressions

OperatorExpression returns Expression:
    BooleanOperator
;

enum BooleanOp:
    AND="&&" | OR="||" | XOR="^^"
;

BooleanOperator returns Expression:
    ComparisonOperator (
        {BooleanOperator.left=current} op=BooleanOp right=ComparisonOperator
    )*
;

enum ComparisonOp:
    LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | EQ="==" | NOT_EQ="!="
;

ComparisonOperator returns Expression:
    AdditiveOperator (
        {ComparisonOperator.left=current} op=ComparisonOp right=AdditiveOperator
    )*
;

enum AdditiveOp returns ArithmeticOp:
    ADD="+" | SUB="-"
;

AdditiveOperator returns Expression:
    MultiplicativeOperator (
        {ArithmeticBinaryOperator.left=current} op=AdditiveOp right=MultiplicativeOperator
    )*
;

enum MultiplicativeOp returns ArithmeticOp:
    MUL="*" | DIV="/"
;

MultiplicativeOperator returns Expression:
    UnaryOperator (
        {ArithmeticBinaryOperator.left=current} op=MultiplicativeOp right=UnaryOperator
    )*
;

UnaryOperator returns Expression:
	NegationOperator
	| ArithmeticUnaryOperator
	| PrimaryExpression
;

NegationOperator:
	'!' body=UnaryOperator
;

enum UnaryOp:
	PLUS="+" | MINUS="-"
;

ArithmeticUnaryOperator:
    op=UnaryOp body=UnaryOperator
;

PrimaryExpression returns Expression:
      ReferenceExpression
    | LiteralExpression
    | '(' Expression ')'
;

// Literal expressions

LiteralExpression:
    LiteralBoolean
    | LiteralInteger
;

LiteralBoolean:
    value = BooleanValue
;

LiteralInteger:
    value = INT
;

BooleanValue returns Ecore::EBoolean:
    'true' | 'false'
;

// Reference expressions

ReferenceExpression:
    ChainingExpression
    | SelfReference
    | NothingReference
;

ChainingExpression:
    chains+=FQNElementReferenceExpression
    (
        '.' chains+=ElementReferenceExpression
    )*
;

ElementReferenceExpression:
    element=[NamedElement|KeywordID]
;

FQNElementReferenceExpression returns ElementReferenceExpression:
    element=[NamedElement|FQN]
;

SelfReference:
    {SelfReference} 'Self'
;

NothingReference:
    {NothingReference} 'Nothing'
;

FQN:
    KeywordID ('::' KeywordID)*
;

KeywordID:
    ID | KEYWORD
;

KEYWORD:
    'init'
    | 'havoc'
;
