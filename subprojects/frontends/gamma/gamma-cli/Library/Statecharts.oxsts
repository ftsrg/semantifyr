/*
 * SPDX-FileCopyrightText: 2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package semantifyr::gamma::statecharts

import semantifyr::gamma::expressions
import semantifyr::gamma::variables
import semantifyr::gamma::components
import semantifyr::gamma::triggers
import semantifyr::gamma::actions
import semantifyr::gamma::events

class Statechart : Component {
    contains regions: Region[0..*]
    contains variables: Variable[0..*]

    redefine init {
        inline for (region in regions) {
            inline region.activateRecursive()
        }
    }

    redefine tran {
        inline resetOutputEvents()

        choice {
            inline for (region in regions) {
                inline region.fireTransitions()
            }
        } else {
        }

        inline resetInputEvents()
    }
}

class Region {
    contains states: State[0..*] opposite parentRegion
    container parentState: State[0..1] opposite regions

    contains abstractTransitions: AbstractTransition[0..*]
    contains transitions: Transition[0..*] subsets abstractTransitions
    contains entryTransitions: EntryTransition[0..*] subsets abstractTransitions

    @Control
    var activeState: states[0..1] := nothing

    tran activateRecursive() {
        inline for (transition in entryTransitions) {
            inline transition.main()
        }
    }
    tran deactivateRecursive() {
        inline for (state in states) {
            inline state.deactivateRecursive()
        }
    }
    tran fireTransitions() {
        /*
        // bottom-up
        var eventConsumed := false

        inline for choice (state in states) {
            inline state.fireTransitions()
            eventConsumed := true
        }

        if (eventConsumed == false) {
            inline for choice (transition in transitions) {
                inline transition.main()
            }
        }
    */
    
        // top-down
        inline for choice (transition in transitions) {
            inline transition.main()
        } else {
            inline for choice (state in states) {
                inline state.fireTransitions()
            } else { }
        }
     
    }
}

/*
 * pattern parentState(childState: State, parentState: State) {
 *     State.regions(parentState, parentRegion)
 *     Region.states(parentRegion, childState)
 * }
 */
class State {
    container parentRegion: Region[1] opposite states
    contains regions: Region[0..*] opposite parentState

    refers parentState: State[0..1] = parentRegion.parentState // as pattern parentState
    contains entryActions: Action[0..*]
    contains exitActions: Action[0..*]

    prop isActive() {
        return parentRegion?.activeState == self
    }
    tran deactivateRecursive() {
        inline for (region in regions) {
            inline region.deactivateRecursive()
        }

        if (parentRegion.activeState == self) {
            parentRegion.activeState := nothing

            inline for (exitAction in exitActions) {
                inline exitAction.main()
            }
        }
    }
    tran exitRecursive(commonRegion : Region) {
        inline for (exitAction in exitActions) {
            inline exitAction.main()
        }

        parentRegion.activeState := nothing

        inline if (commonRegion != parentRegion) {
            inline if (parentState != nothing) {
                inline parentState.exitRecursive(commonRegion)
            }
        }
    }
    tran exit(commonRegion : Region) {
        inline exitRecursive(commonRegion)

        inline for (region in regions) {
            inline region.deactivateRecursive()
        }
    }
    tran enterRecursive(commonRegion : Region) {
        inline if (commonRegion != parentRegion) {
            inline if (parentState != nothing) {
                inline parentState.enterRecursive(commonRegion)
            }
        }

        parentRegion.activeState := self

        inline for (action in entryActions) {
            inline action.main()
        }
    }
    tran enter(commonRegion : Region) {
        inline enterRecursive(commonRegion)

        inline for (region in regions) {
            inline region.activateRecursive()
        }
    }
    tran fireTransitions() {
        inline if (regions == nothing) {
            assume (false)
        } else {
            assume (isActive())
            choice {
                inline for (region in regions) {
                    inline region.fireTransitions()
                }
            } else {
            }
        }
    }
}

class AbstractTransition {
    container commonRegion: Region[1] opposite transitions

    refers to: State[1]
}

class EntryTransition : AbstractTransition {
    redefine tran {
        inline to.enter(commonRegion)
    }
}

class Transition : AbstractTransition {
    refers from: State[1]

    features trigger: Trigger[1]
    
    contains actions: Action[0..*]
    features guard: Guard[0..1]

    redefine tran {
        inline trigger.assumeIsTriggered()
        assume (from.isActive())
        inline if (guard != nothing) {
            inline guard.assumeIsTrue()
        }

        inline from.exit(commonRegion)
        inline for (action in actions) {
            inline action.main()
        }
        inline to.enter(commonRegion)
    }
}

class StateReachabilityExpression : Expression {
    refers state: State

    redefine prop evaluate() {
        return state.isActive()
    }
}

/*
 * pattern parallelRegions(r1: Region, r2: Region) {
 *     State.regions(state, r1)
 *     State.regions(state, r2)
 *     r1 != r2
 * }

 * neg constraint noParallelRegionTransitions(t: Transition) {
 *     Transition.from(t, from)
 *     Transition.to(t, to)
 *     Region.states(fromR, from)
 *     Region.states(toR, to)
 *     fromR != toR
 * }

 * neg constraint noParallelRegions(state: State) {
 *     State.regions(state, r1)
 *     State.regions(state, r2)
 *     find parallelRegions(r1, r2)
 * }
 */
