/*
 * SPDX-FileCopyrightText: 2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package semantifyr::gamma::statecharts

import semantifyr::gamma::expressions
import semantifyr::gamma::variables
import semantifyr::gamma::components
import semantifyr::gamma::triggers
import semantifyr::gamma::actions
import semantifyr::gamma::events

class Statechart : Component {
    contains regions : Region[0..*] opposite parent
    contains variables : Variable[0..*]

    redefine init {
        inline for (region in regions) {
            inline region.activateRecursive()
        }
    }

    redefine tran {
        inline resetOutputEvents()

        choice {        
            inline for (region in regions) {
                inline region.fireTransitions()
            }
        } else { }

        inline resetInputEvents()
    }
}

class Region {
    contains states : State[0..*] opposite parentRegion
    container parent : State[0..1] opposite regions

    contains abstractTransitions : AbstractTransition[0..*]
    contains transitions : Transition[0..*] subsets abstractTransitions
    contains entryTransitions : EntryTransition[0..*] subsets abstractTransitions

    @Control
    var activeState : states[0..1] := nothing

    tran activateRecursive() {
        inline for (transition in entryTransitions) {
            inline transition.main()
        }
    }

    tran deactivateRecursive() {        
        inline for (state in states) {
            inline state.deactivateRecursive()
        }
    }

    tran fireTransitions() {
        inline for choice (transition in transitions) {
            inline transition.main()
        } else {
            inline for choice (state in states) {
                inline state.fireTransitions()
            } else { }
        }
    }
}

/*
pattern parentState(childState: State, parentState: State) {
    State.regions(parentState, parentRegion)
    Region.states(parentRegion, childState)
}
*/

class State {
    container parentRegion : Region[0..1] opposite states    
    contains regions : Region[0..*] opposite parent

    refers parentState : State[0..1] = parentRegion.parent //as pattern parentState

    contains entryActions : Action[0..*]
    contains exitActions : Action[0..*]

    prop isActive() {
        parentRegion.activeState == self
    }

    tran deactivateRecursive() {
        inline for (region in regions) {
            inline region.deactivateRecursive()
        }

        if (parentRegion.activeState == self) {
            parentRegion.activeState := nothing

            inline for (exitAction in exitActions) {
                inline exitAction.main()
            }
        }
    }

    tran exitRecursive(commonRegion : Region) {            
        inline for (exitAction in exitActions) {
            inline exitAction.main()
        }

        parentRegion.activeState := nothing

        inline if (commonRegion != parentRegion) {
            inline parentState.exitRecursive(commonRegion)
        }
    }

    tran exit(commonRegion : Region) {
        inline exitRecursive(commonRegion)

        inline for (region in regions) {
            inline region.deactivateRecursive()
        }
    }

    tran enterRecursive(commonRegion : Region) {
        inline if (commonRegion != parentRegion) {
            inline parentState.enterRecursive(commonRegion)
        }

        parentRegion.activeState := self

        inline for (action in entryActions) {
            inline action.main()
        }
    }

    tran enter(commonRegion : Region) {
        inline enterRecursive(commonRegion)

        inline for (region in regions) {
            inline region.activateRecursive()
        }
    }

    tran fireTransitions() {
        inline if (regions == nothing) {
            assume (false)
        } else {
            assume (isActive)
            choice {
                inline for (region in regions) {
                    inline region.fireTransitions()
                }
            } else { }
        }
    }
}

class AbstractTransition {
    container commonRegion: Region[1] opposite transitions

    refers to : State[1]
}

class EntryTransition : AbstractTransition {
    redefine tran {
        inline to.enter(commonRegion)
    }
}

class Transition : AbstractTransition {
    refers from : State[1]

    contains trigger : Trigger[1]
    contains actions : Action[0..*]
    contains guards : Guard[0..*]

    tran {
        inline trigger.isTriggered()
        assume (from.isActive)
        inline for (guard in guards) {
            inline guard.main()
        }

        inline from.exit(commonRegion)

        inline for (action in actions) {
            inline action.main()
        }

        inline to.enter(commonRegion)
    }
}

class StateReachabilityExpression : Expression {
    refers state : State
    
    prop evaluate() {
        state.isActive()
    }
}

/*
pattern parallelRegions(r1: Region, r2: Region) {
    State.regions(state, r1)
    State.regions(state, r2)
    r1 != r2
}

neg constraint noParallelRegionTransitions(t: Transition) {
    Transition.from(t, from)
    Transition.to(t, to)
    Region.states(fromR, from)
    Region.states(toR, to)
    fromR != toR
}

neg constraint noParallelRegions(state: State) {
    State.regions(state, r1)
    State.regions(state, r2)
    find parallelRegions(r1, r2)
}
*/
