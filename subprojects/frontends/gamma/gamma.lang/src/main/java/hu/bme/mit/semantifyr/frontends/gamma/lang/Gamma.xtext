/*
 * SPDX-FileCopyrightText: 2025 The Semantifyr Authors
 *
 * SPDX-License-Identifier: EPL-2.0
 */

grammar hu.bme.mit.semantifyr.frontends.gamma.lang.Gamma with org.eclipse.xtext.common.Terminals

generate gamma "http://www.bme.hu/mit/2025/gamma"

import "http://www.eclipse.org/emf/2002/Ecore" as Ecore

GammaModelPackage:
    'package' name=Identifier

    (
        interfaces += InterfaceDeclaration
        | components += ComponentDeclaration
        | verificationCases += VerificationCaseDeclaration
    )*
;

InterfaceDeclaration:
    'interface' name=Identifier '{'
        events += EventDeclaration*
    '}'
;

enum EventDirection:
	IN = 'in' | OUT = 'out' // | INOUT = 'inout' | INTERNAL = 'internal'
;

EventDeclaration:
    direction=EventDirection 'event' name=Identifier
;

ComponentDeclaration:
    SyncComponentDeclaration
    | StatechartDeclaration
;

SyncComponentDeclaration:
    'sync' 'component' name=Identifier
    ('[' (ports += PortDeclaration (',' ports += PortDeclaration)*)? ']')?
    '{'
        (
            components += ComponentInstance
            | channels += Channel
            | bindings += PortBinding
        )*
    '}'
;

ComponentInstance:
    'component' name=ID ':' component=[ComponentDeclaration|Identifier]
;

enum RealizationMode:
	PROVIDED = 'provides' | REQUIRED = 'requires'
;

PortDeclaration:
    'port' name=Identifier ':' realizationMode=RealizationMode interface=[InterfaceDeclaration|Identifier]
;

StatechartDeclaration:
	'statechart' name=Identifier
    ('[' (ports += PortDeclaration (',' ports += PortDeclaration)*)? ']')?
	'{'
        (
            variables += VariableDeclaration
            | timeouts += TimeoutDeclaration
            | regions += Region
        )*
	'}'
;

TypeReference:
    IntegerType
    | BooleanType
;

IntegerType:
    {IntegerType} 'Integer'
;

BooleanType:
    {BooleanType} 'Boolean'
;

VariableDeclaration:
    'var' name=Identifier ':' type = TypeReference (':=' default=LiteralExpression)?
;

TimeoutDeclaration:
    'timeout' name=Identifier
;

Region:
    'region' name=Identifier '{'
        (
            states += State
            | transitions += Transition
        )*
    '}'
;

State:
    'state' name=Identifier ('{'
        ('entry' '/' entryActions+=Action+)?
        ('exit' '/' exitActions+=Action+)?

        regions+=Region*
    '}')?
;

Transition:
    EntryTransition
    | StateTransition
;

EntryTransition:
    'entry' 'transition' 'to' to=[State|Identifier]
;

StateTransition:
    'transition' from=[State] 'to' to=[State|Identifier]
    ('when' trigger=Trigger)?
    ('[' guard=Expression ']')?
    ('/' actions+=Action+)?
;

Trigger:
    TimeoutTrigger
    | EventTrigger
;

TimeoutTrigger:
    'timeout' timeout=[TimeoutDeclaration|Identifier]
;

EventTrigger:
    'event' port=[PortDeclaration|Identifier] '.' event=[EventDeclaration|Identifier]
;

Action:
    RaiseEventAction
    | SetTimeoutAction
    | AssignmentAction
;

RaiseEventAction:
    'raise' port=[PortDeclaration|Identifier] '.' event=[EventDeclaration|Identifier] ';'
;

SetTimeoutAction:
    'set' timeout=[TimeoutDeclaration|Identifier] ':=' value=Expression 's' ';'
;

AssignmentAction:
    'assign' variable=[VariableDeclaration|Identifier] ':=' expression=Expression ';'
;

InstancePortReference:
	instance=[ComponentInstance|Identifier] '.' port=[PortDeclaration|Identifier]
;

PortBinding:
	'bind' port=[PortDeclaration|Identifier] '->' boundPort=InstancePortReference
;

Channel:
	'channel' '[' providedPort=InstancePortReference ']' '->' '[' requiredPort=InstancePortReference ']'
;

VerificationCaseDeclaration:
    (reachable?='@Reachable' | '@Unreachable')
    'verification' 'case' name=Identifier '{'
        component = ComponentInstance
        'invariant' '{' invariant=Expression '}'
    '}'
;

Expression:
	OperatorExpression
;

OperatorExpression returns Expression:
    BooleanOperator
;

enum BooleanOp:
    AND='&&' | OR='||'
    | AND='and' | OR='or'
;

BooleanOperator returns Expression:
    ComparisonOperator (
        {BooleanOperator.left=current} op=BooleanOp right=ComparisonOperator
    )*
;

enum ComparisonOp:
	LESS="<" | LESS_EQ="<=" | GREATER=">" | GREATER_EQ=">=" | EQ="==" | NOT_EQ="!="
;

ComparisonOperator returns Expression:
    AdditiveOperator (
        {ComparisonOperator.left=current} op=ComparisonOp right=AdditiveOperator
    )*
;

enum AdditiveOp returns ArithmeticOp:
	ADD="+" | SUB="-"
;

AdditiveOperator returns Expression:
    MultiplicativeOperator (
        {ArithmeticBinaryOperator.left=current} op=AdditiveOp right=MultiplicativeOperator
    )*
;

enum MultiplicativeOp returns ArithmeticOp:
    MUL='*' | DIV='/'
;

MultiplicativeOperator returns Expression:
    UnaryOperator (
        {ArithmeticBinaryOperator.left=current} op=MultiplicativeOp right=UnaryOperator
    )*
;

UnaryOperator returns Expression:
	NegationOperator
	| ArithmeticUnaryOperator
	| PostfixUnaryExpression
;

NegationOperator:
	'!' body=UnaryOperator
;

enum UnaryOp:
	PLUS="+" | MINUS="-"
;

ArithmeticUnaryOperator:
    op=UnaryOp body=UnaryOperator
;

PostfixUnaryExpression returns Expression:
    PrimaryExpression -> (
        ({NavigationSuffixExpression.primary=current} '.' member=[Ecore::EObject|Identifier])
    )*
;

PrimaryExpression returns Expression:
	ElementReferenceExpression
	| IsStateActiveExpression
	| LiteralExpression
	| '(' Expression ')'
;

IsStateActiveExpression:
    'isActive' '(' expression=Expression ')'
;

// Literal expressions

LiteralExpression:
	 LiteralBoolean
	 | LiteralInteger
;

LiteralBoolean:
	value = BooleanValue
;

LiteralInteger:
	value = INT
;

BooleanValue returns Ecore::EBoolean:
	'true' | 'false'
;

ElementReferenceExpression:
	element=[Ecore::EObject|Identifier]
;

Identifier:
    ID
;

terminal ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
